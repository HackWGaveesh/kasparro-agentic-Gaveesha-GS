# Project Documentation

## Problem Statement

Design and implement a modular agentic automation system that takes a small product dataset and automatically generates structured, machine-readable content pages. The system must:

1. Parse and understand product data into a clean internal model
2. Automatically generate at least 15 categorized user questions
3. Define and implement custom templates for FAQ Page, Product Description Page, and Comparison Page
4. Create reusable "content logic blocks" (functions/modules that apply rules to transform data into copy)
5. Assemble 3 pages using agents: FAQ Page (5 Q&As minimum), Product Page, Comparison Page (GlowBoost vs fictional Product B)
6. Output each page as clean, machine-readable JSON
7. The entire pipeline must run via agents, not a single-script GPT wrapper

**Key Constraint**: Use ONLY the provided JSON-like product dataset. Do not add new facts or research externally.

## Solution Overview

I've built a **modular multi-agent architecture** using **LangGraph** for orchestration. The system is designed with clear separation of concerns:

- **7 Specialized Agents** - Each with a single, well-defined responsibility
- **4 Reusable Content Logic Blocks** - Pure functions that transform data into structured content
- **3 Custom Templates** - Flexible template system for different page types
- **DAG-Based Workflow** - LangGraph orchestration with proper state management
- **JSON Output** - All pages output as machine-readable JSON files

The system processes the provided GlowBoost Vitamin C Serum data and generates:
- `faq.json`: FAQ page with 5+ Q&As across multiple categories
- `product_page.json`: Complete product description with all sections
- `comparison_page.json`: Comparison with a fictional Product B (generated by the system)

## Scopes & Assumptions

### In Scope

- Multi-agent system architecture with clear agent boundaries
- Template-based content generation system
- Reusable content logic blocks
- Structured JSON output
- Automated workflow execution via LangGraph
- Product data parsing and validation
- LLM-based question and answer generation
- Fictional product generation for comparison

### Out of Scope

- External data research (uses only provided product data)
- UI/website development
- Database integration
- User authentication
- Real-time API integrations beyond OpenRouter
- Content quality scoring (though structure is validated)
- Multi-product batch processing

### Assumptions

- Product data is provided in the specified JSON format
- OpenRouter API is accessible with free model access
- Python 3.9+ environment available
- All dependencies can be installed via pip
- Output directory is writable
- User has configured OpenRouter privacy settings for free models

## System Design

### Architecture Overview

The system follows a **layered agentic architecture** with clear separation of concerns:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Workflow Orchestration Layer                    â”‚
â”‚                   (LangGraph DAG)                            â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Data Parser  â”‚  â”‚   Content    â”‚  â”‚   Question    â”‚    â”‚
â”‚  â”‚   Agent      â”‚  â”‚   Blocks     â”‚  â”‚   Generator   â”‚    â”‚
â”‚  â”‚              â”‚  â”‚   Agent     â”‚  â”‚   Agent      â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â”‚                 â”‚                  â”‚             â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                           â”‚                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚   FAQ        â”‚  â”‚  Product    â”‚  â”‚  Comparison  â”‚    â”‚
â”‚  â”‚ Generator    â”‚  â”‚  Page      â”‚  â”‚  Generator    â”‚    â”‚
â”‚  â”‚   Agent      â”‚  â”‚ Generator  â”‚  â”‚  Agent       â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â”‚                 â”‚                 â”‚             â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                           â”‚                                â”‚
â”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚                  â”‚  JSON Output    â”‚                      â”‚
â”‚                  â”‚     Agent       â”‚                      â”‚
â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚   JSON Files       â”‚
                  â”‚   (outputs/)      â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Detailed Workflow DAG

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Product Data   â”‚
                    â”‚    (Input)      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Data Parser    â”‚
                    â”‚     Agent       â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                â”‚                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
    â”‚   Content     â”‚ â”‚  Question    â”‚ â”‚              â”‚
    â”‚   Blocks      â”‚ â”‚  Generator   â”‚ â”‚              â”‚
    â”‚   Agent       â”‚ â”‚  Agent       â”‚ â”‚              â”‚
    â”‚               â”‚ â”‚              â”‚ â”‚              â”‚
    â”‚ Generates:    â”‚ â”‚ Generates:   â”‚ â”‚              â”‚
    â”‚ â€¢ Benefits    â”‚ â”‚ â€¢ 15+ Q&As  â”‚ â”‚              â”‚
    â”‚ â€¢ Usage       â”‚ â”‚ â€¢ Categories â”‚ â”‚              â”‚
    â”‚ â€¢ Ingredients â”‚ â”‚ â€¢ Answers   â”‚ â”‚              â”‚
    â”‚ â€¢ Safety      â”‚ â”‚              â”‚ â”‚              â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                â”‚
            â”‚                â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
    â”‚               â”‚ â”‚              â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚ Product  â”‚ â”‚ Comparison  â”‚ â”‚     FAQ      â”‚
â”‚ Page     â”‚ â”‚ Generator   â”‚ â”‚   Generator   â”‚
â”‚ Generatorâ”‚ â”‚ Agent       â”‚ â”‚   Agent      â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
    â”‚                â”‚                 â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  JSON Output    â”‚
            â”‚     Agent       â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  faq.json       â”‚
            â”‚  product_page    â”‚
            â”‚  .json           â”‚
            â”‚  comparison_page â”‚
            â”‚  .json           â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Agent Responsibilities

#### 1. Data Parser Agent
- **File**: `agents/data_parser_agent.py`
- **Responsibility**: Parse raw product data into clean internal model
- **Input**: Raw product data dictionary
- **Output**: Validated Product model (Pydantic)
- **LLM Usage**: Only if data structure needs fixing (uses LLM with tools to repair invalid data)
- **Tools Used**: `validate_data_structure`, `analyze_product_data`
- **Key Features**:
  - Uses tools to validate data structure before parsing
  - Uses agent reasoning with tools if validation fails
  - Converts data types (strings to lists, etc.)
  - Uses Pydantic for type safety
  - Returns structured Product model

#### 2. Content Blocks Agent
- **File**: `agents/content_blocks_agent.py`
- **Responsibility**: Generate all reusable content logic blocks
- **Input**: Parsed product data
- **Output**: Dictionary of content blocks (benefits, usage, ingredients, safety)
- **LLM Usage**: Only if content needs analysis (uses tools for reasoning)
- **Tools Used**: `analyze_content_needs`, `analyze_product_data`
- **Key Features**:
  - Uses `analyze_content_needs` tool to determine which blocks are needed
  - Uses agent reasoning with tools if analysis indicates issues
  - Calls all content block functions based on tool analysis
  - Aggregates results into structured dictionary
  - Optimized: Tool analysis is pure function (no API call)

#### 3. Question Generator Agent
- **File**: `agents/question_generator_agent.py`
- **Responsibility**: Generate 15+ categorized questions with answers
- **Input**: Product data
- **Output**: List of categorized questions with answers
- **LLM Usage**: Yes - generates questions via OpenRouter API with tool calling
- **Tools Used**: `categorize_question`, `generate_answer_for_question`, `validate_question_structure`, `analyze_product_data`
- **Categories**: Informational, Safety, Usage, Purchase, Comparison
- **Key Features**:
  - Uses LangChain tools bound to LLM for question categorization
  - Uses `generate_answer_for_question` tool (which uses LLM) for all answers
  - Uses `validate_question_structure` tool to ensure quality
  - Uses `analyze_product_data` tool to understand product structure
  - Ensures minimum 15 questions across categories
  - No hardcoded responses - all via tools

#### 4. FAQ Generator Agent
- **File**: `agents/faq_generator_agent.py`
- **Responsibility**: Generate FAQ page using FAQ template
- **Input**: Product data + Questions
- **Output**: Structured FAQ page dictionary
- **LLM Usage**: Only if validation fails (uses tools for reasoning)
- **Tools Used**: `select_best_questions`, `validate_faq_structure`, `validate_question_structure`
- **Key Features**:
  - Uses `select_best_questions` tool to intelligently select top 5 questions
  - Uses `validate_faq_structure` tool to ensure FAQ quality
  - Uses agent reasoning with tools if validation fails
  - Applies FAQ template
  - Structures Q&As into FAQ format
  - Validates minimum 5 Q&As requirement
  - Optimized: Question selection is pure function (no API call)

#### 5. Product Page Generator Agent
- **File**: `agents/product_page_generator_agent.py`
- **Responsibility**: Generate product description page
- **Input**: Product data + Content blocks
- **Output**: Structured product page dictionary
- **LLM Usage**: Only if structure analysis indicates issues (uses tools for reasoning)
- **Tools Used**: `analyze_page_structure`, `analyze_product_data`
- **Key Features**:
  - Uses `analyze_page_structure` tool to determine required sections
  - Uses agent reasoning with tools to optimize page structure
  - Combines all content blocks based on tool analysis
  - Applies Product Description template
  - Structures complete product information
  - Includes all sections (overview, ingredients, benefits, usage, safety)
  - Optimized: Structure analysis is pure function (no API call)

#### 6. Comparison Generator Agent
- **File**: `agents/comparison_generator_agent.py`
- **Responsibility**: Generate comparison page with fictional Product B
- **Input**: Product A data
- **Output**: Structured comparison page dictionary
- **LLM Usage**: Yes - generates fictional Product B via OpenRouter API
- **Key Features**:
  - Generates realistic fictional Product B
  - Validates Product B structure
  - Compares products using comparison tools
  - Applies Comparison template
  - No hardcoded Product B - always generated fresh

#### 7. JSON Output Agent
- **File**: `agents/json_output_agent.py`
- **Responsibility**: Format and save pages as JSON files
- **Input**: All generated pages (FAQ, Product, Comparison)
- **Output**: JSON files (faq.json, product_page.json, comparison_page.json)
- **LLM Usage**: Only if JSON validation fails (uses tools for reasoning)
- **Tools Used**: `validate_json_structure`
- **Key Features**:
  - Uses `validate_json_structure` tool to validate each page before saving
  - Uses agent reasoning with tools if validation fails
  - Formats dictionaries as clean JSON
  - Saves to outputs/ directory
  - Ensures all JSON is valid and serializable
  - Returns file paths
  - Optimized: JSON validation is pure function (no API call)

### Content Logic Blocks

Reusable functions that transform product data into structured content. These are **not agents** - they're pure transformation logic.

#### Benefits Block (`content_blocks/benefits_block.py`)
- **Function**: `generate_benefits_content(product_data)`
- **Purpose**: Structures benefits from product data
- **Input**: Product data dictionary
- **Output**: Structured benefits content with:
  - Primary benefits list
  - Ingredient-to-benefit mapping
  - Formatted benefit descriptions
- **Logic**: Maps ingredients to benefits, structures benefit information

#### Usage Block (`content_blocks/usage_block.py`)
- **Function**: `generate_usage_content(product_data)`
- **Purpose**: Structures usage instructions
- **Input**: Product data dictionary
- **Output**: Structured usage content with:
  - Step-by-step instructions
  - Usage frequency
  - Application tips
  - Precautions
- **Logic**: Extracts steps from instructions, determines frequency, generates tips

#### Ingredients Block (`content_blocks/ingredients_block.py`)
- **Function**: `generate_ingredients_content(product_data)`
- **Purpose**: Structures ingredients information
- **Input**: Product data dictionary
- **Output**: Structured ingredients content with:
  - Key ingredients list
  - Ingredient details (type, benefits, description)
  - Active vs supporting ingredients
- **Logic**: Maps ingredients to detailed information, categorizes ingredients

#### Safety Block (`content_blocks/safety_block.py`)
- **Function**: `generate_safety_content(product_data)`
- **Purpose**: Structures safety information
- **Input**: Product data dictionary
- **Output**: Structured safety content with:
  - Side effects
  - Safety notes
  - Warnings
  - Contraindications
- **Logic**: Generates safety notes from side effects, creates warnings

### Template Engine

The template engine (`templates/template_engine.py`) provides a flexible system for generating structured pages.

#### Template Interface

```python
class Template(ABC):
    @abstractmethod
    def get_fields(self) -> List[str]:
        """Returns required fields for this template"""
    
    @abstractmethod
    def apply(self, data: Dict, content_blocks: Dict) -> Dict:
        """Applies template to data and returns structured output"""
```

#### Implemented Templates

**1. FAQ Template**
- **Input**: Questions list + Product data
- **Output**: Structured FAQ page with:
  - Page type
  - Product name
  - FAQ items (question, answer, category)
  - Total questions count
  - Categories list
- **Minimum**: 5 Q&As (as per assignment requirement)

**2. Product Description Template**
- **Input**: Product data + All content blocks
- **Output**: Structured product page with sections:
  - Overview (name, concentration, price)
  - Ingredients (detailed ingredient information)
  - Benefits (structured benefits)
  - Usage (instructions, tips, precautions)
  - Safety (side effects, warnings)
  - Skin Type (compatibility)
- **Structure**: Complete product information page

**3. Comparison Template**
- **Input**: Product A + Product B data + Comparison data
- **Output**: Structured comparison page with:
  - Product details for both products
  - Ingredient comparison (common, unique to each)
  - Price comparison
  - Benefits comparison
  - Skin type overlap
  - Recommendation
- **Structure**: Side-by-side comparison format

### Workflow Orchestration

The workflow (`workflow/product_workflow.py`) implements a **DAG structure** using LangGraph:

```python
# Workflow Definition
workflow = StateGraph(ProductState)

# Nodes (Agents)
workflow.add_node("data_parser", data_parser_node)
workflow.add_node("content_blocks", content_blocks_node)
workflow.add_node("question_generator", question_generator_node)
workflow.add_node("faq_generator", faq_generator_node)
workflow.add_node("product_page_generator", product_page_generator_node)
workflow.add_node("comparison_generator", comparison_generator_node)
workflow.add_node("json_output", json_output_node)

# Edges (Dependencies)
workflow.set_entry_point("data_parser")
workflow.add_edge("data_parser", "content_blocks")
workflow.add_edge("data_parser", "question_generator")  # Parallel
workflow.add_edge("content_blocks", "product_page_generator")
workflow.add_edge("content_blocks", "comparison_generator")
workflow.add_edge("question_generator", "faq_generator")
workflow.add_edge("faq_generator", "json_output")
workflow.add_edge("product_page_generator", "json_output")
workflow.add_edge("comparison_generator", "json_output")
workflow.add_edge("json_output", END)
```

**Key Features**:
- **Parallel Execution**: Content Blocks and Question Generator run in parallel
- **Sequential Dependencies**: Pages depend on their inputs, JSON output depends on all pages
- **State Management**: LangGraph's TypedDict ensures type safety
- **No Hardcoded Fallbacks**: All content generated via agents

### State Management

State schema (`state/product_state_schema.py`) defines the shared state:

```python
class ProductState(TypedDict):
    # Input
    raw_product_data: Dict[str, Any]
    
    # Intermediate
    parsed_product: Dict[str, Any]
    content_blocks: Dict[str, Any]
    questions: List[Dict[str, Any]]
    
    # Output
    faq_page: Dict[str, Any]
    product_page: Dict[str, Any]
    comparison_page: Dict[str, Any]
    
    # Final
    files_created: List[str]
    json_output_complete: bool
    
    # Error handling
    errors: List[str]
```

**State Flow**:
1. `raw_product_data` â†’ Input
2. `parsed_product` â†’ After Data Parser
3. `content_blocks` + `questions` â†’ After parallel generation
4. `faq_page` + `product_page` + `comparison_page` â†’ After page generation
5. `files_created` â†’ After JSON output

### Data Flow

```
1. Input
   â””â”€> Raw product data (JSON dictionary)
   
2. Parsing
   â””â”€> Data Parser Agent validates and structures data
       â””â”€> Product model (Pydantic)
   
3. Content Generation (Parallel)
   â”œâ”€> Content Blocks Agent
   â”‚   â””â”€> Benefits, Usage, Ingredients, Safety blocks
   â”‚
   â””â”€> Question Generator Agent
       â””â”€> 15+ categorized questions with answers
   
4. Page Generation
   â”œâ”€> FAQ Generator Agent
   â”‚   â””â”€> FAQ template â†’ FAQ page
   â”‚
   â”œâ”€> Product Page Generator Agent
   â”‚   â””â”€> Product template â†’ Product page
   â”‚
   â””â”€> Comparison Generator Agent
       â”œâ”€> Generate fictional Product B (LLM)
       â””â”€> Comparison template â†’ Comparison page
   
5. Output
   â””â”€> JSON Output Agent
       â””â”€> faq.json, product_page.json, comparison_page.json
```

### Extensibility

The system is designed for extensibility:

**Adding New Agents**:
1. Create agent class in `agents/`
2. Implement `process(state)` method
3. Add node to workflow in `workflow/product_workflow.py`
4. Add edges for dependencies

**Adding New Templates**:
1. Extend `Template` class in `templates/template_engine.py`
2. Implement `get_fields()` and `apply()` methods
3. Register in `TemplateEngine.apply_template()`

**Adding New Content Blocks**:
1. Create function in `content_blocks/`
2. Add to `ContentBlocksAgent` in `agents/content_blocks_agent.py`
3. Use in templates or agents

**Adding New Output Formats**:
1. Extend `JSONOutputAgent` or create new output agent
2. Add to workflow
3. Update state schema if needed

### Error Handling

- **Validation**: Data validation at parsing stage (Pydantic)
- **Error Collection**: Errors collected in state `errors` list
- **Graceful Degradation**: Agents return error messages in state
- **No Silent Failures**: All errors are reported
- **LLM Retries**: Built into LangChain's ChatOpenAI (max_retries=3)

## Technical Implementation

### Framework: LangGraph

**Why LangGraph?**
- Required by assignment (framework-based approach)
- Provides DAG orchestration
- Built-in state management
- Checkpointing support
- Agent communication patterns

**Features Used**:
- `StateGraph` for workflow definition
- `TypedDict` for state schema
- `MemorySaver` for checkpointing
- DAG edges for dependencies
- Parallel node execution

### Agent Tool Usage: LangChain Tools

**Why Tools?**
- Enable agents to reason independently, not just wrap API calls
- Provide structured decision-making capabilities
- Allow validation and analysis without always requiring LLM calls
- Meet assignment requirement for "agents with independent reasoning"

**Tool Architecture**:
- **12 Tools Available**: All agents can access relevant tools
- **Pure Function Tools**: Tools like `validate_data_structure`, `select_best_questions` are pure functions (no API calls)
- **LLM-Based Tools**: Tools like `generate_answer_for_question` use LLM when needed
- **Tool Binding**: All agents use `bind_tools()` to enable LLM tool calling
- **Optimized Usage**: Agents use pure function tools first, LLM reasoning only when needed

**Tools by Agent**:
- **DataParserAgent**: `validate_data_structure`, `analyze_product_data`
- **ContentBlocksAgent**: `analyze_content_needs`, `analyze_product_data`
- **QuestionGeneratorAgent**: `categorize_question`, `generate_answer_for_question`, `validate_question_structure`, `analyze_product_data`
- **FAQGeneratorAgent**: `select_best_questions`, `validate_faq_structure`, `validate_question_structure`
- **ProductPageGeneratorAgent**: `analyze_page_structure`, `analyze_product_data`
- **ComparisonGeneratorAgent**: `validate_product_structure`, `compare_products`
- **JSONOutputAgent**: `validate_json_structure`

### LLM Integration: OpenRouter

**Model**: `openai/gpt-oss-120b:free`

**Usage**:
- Question generation (QuestionGeneratorAgent)
- Answer generation (via `generate_answer_for_question` tool)
- Fictional product generation (ComparisonGeneratorAgent)

**Configuration**:
- Base URL: `https://openrouter.ai/api/v1`
- API key from environment or config
- Temperature: 0.7-0.8 for generation
- Max retries: 3

**No Fallbacks**: All LLM calls are real API calls - no hardcoded responses.

### Data Validation: Pydantic

**Why Pydantic?**
- Type safety
- Automatic validation
- Clear error messages
- Python 3.9+ compatible

**Usage**:
- Product model (`models/product_model.py`)
- State schema validation (implicit via TypedDict)
- Tool input validation (LangChain)

### Output Format: JSON

**Structure**: Clean, machine-readable JSON

**Files**:
- `faq.json` - FAQ page structure
- `product_page.json` - Product description structure
- `comparison_page.json` - Comparison page structure

**Location**: `outputs/` directory

**Format**: Pretty-printed JSON with 2-space indentation

## File Structure

```
.
â”œâ”€â”€ agents/                      # Agent implementations
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ data_parser_agent.py
â”‚   â”œâ”€â”€ content_blocks_agent.py
â”‚   â”œâ”€â”€ question_generator_agent.py
â”‚   â”œâ”€â”€ faq_generator_agent.py
â”‚   â”œâ”€â”€ product_page_generator_agent.py
â”‚   â”œâ”€â”€ comparison_generator_agent.py
â”‚   â””â”€â”€ json_output_agent.py
â”‚
â”œâ”€â”€ content_blocks/             # Reusable content logic
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ benefits_block.py
â”‚   â”œâ”€â”€ usage_block.py
â”‚   â”œâ”€â”€ ingredients_block.py
â”‚   â””â”€â”€ safety_block.py
â”‚
â”œâ”€â”€ templates/                   # Template engine
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ template_engine.py
â”‚
â”œâ”€â”€ models/                      # Data models
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ product_model.py
â”‚
â”œâ”€â”€ state/                       # State management
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ product_state_schema.py
â”‚
â”œâ”€â”€ workflow/                    # LangGraph workflow
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ product_workflow.py
â”‚
â”œâ”€â”€ tools/                       # Agent tools (LangChain)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ product_tools.py
â”‚
â”œâ”€â”€ config/                      # Configuration
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ llm_config.py
â”‚
â”œâ”€â”€ outputs/                     # Generated JSON files
â”‚   â”œâ”€â”€ faq.json
â”‚   â”œâ”€â”€ product_page.json
â”‚   â””â”€â”€ comparison_page.json
â”‚
â”œâ”€â”€ docs/                        # Documentation
â”‚   â””â”€â”€ projectdocumentation.md
â”‚
â”œâ”€â”€ main_product.py             # Entry point
â””â”€â”€ requirements.txt            # Dependencies
```

## Execution Flow

1. **Start**: `python main_product.py`
2. **Data Parser**: Validates and structures product data
3. **Parallel Execution**:
   - Content Blocks Agent generates all content blocks
   - Question Generator Agent generates 15+ categorized questions
4. **Page Generation**:
   - FAQ Generator creates FAQ page (5+ Q&As)
   - Product Page Generator creates product description
   - Comparison Generator creates Product B and comparison page
5. **JSON Output**: All pages saved as JSON files
6. **Complete**: System outputs file paths and summary

## Key Design Decisions

1. **Modular Agents**: Each agent has single responsibility - makes system testable and maintainable
2. **Tool-Based Reasoning**: ALL agents use LangChain tools for independent reasoning - addresses "API wrapper" criticism
3. **Reusable Blocks**: Content logic separated from agents - enables composition and reuse
4. **Template Engine**: Flexible template system - easy to add new page types
5. **No Hardcoded Content**: All content generated via agents or logic blocks - meets assignment requirement
6. **Type Safety**: Pydantic models ensure data correctness - catches errors early
7. **Framework-Based**: Uses LangGraph for proper orchestration - not a custom script
8. **JSON Output**: Machine-readable structured output - easy to integrate
9. **State Management**: LangGraph TypedDict for type-safe state - prevents errors
10. **Optimized API Usage**: Pure function tools (no API calls) + LLM reasoning only when needed - respects API limits
11. **Parallel Execution**: Content blocks and questions generated in parallel - efficient

## Testing

**Run the system**:
```bash
python main_product.py
```

**Expected output**:
- 3 JSON files in `outputs/` directory
- FAQ page with 5+ Q&As
- Complete product description page
- Comparison page with fictional Product B

**Verification**:
- Check JSON files are valid
- Verify FAQ has minimum 5 Q&As
- Verify all pages have required fields
- Check no hardcoded content in outputs

## Future Enhancements

If extending this system, I would consider:

- **Multi-Product Support**: Process multiple products in batch
- **Template Customization**: Allow users to define custom templates
- **Enhanced Comparison**: More sophisticated comparison logic
- **Content Quality Scoring**: Add agent to score content quality
- **Caching**: Cache LLM responses for repeated runs
- **Validation**: Add schema validation for JSON output
- **Error Recovery**: More sophisticated error handling and retry logic
- **Monitoring**: Add logging and monitoring for production use

---

**Documentation written with clarity and attention to detail** ðŸ“š
